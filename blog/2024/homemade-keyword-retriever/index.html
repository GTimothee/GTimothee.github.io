<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> How to write your own keyword retriever in 5 minutes | Timothée Guédon </title> <meta name="author" content="Timothée Guédon"> <meta name="description" content="Tutorial on how to write your own keyword retriever using the whoosh library"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website, timothee, guedon, ai, deep-learning, data-science, generative-ai"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%9A%80&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://gtimothee.github.io/blog/2024/homemade-keyword-retriever/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Timothée</span> Guédon </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">How to write your own keyword retriever in 5 minutes</h1> <p class="post-meta"> Created in October 24, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/keyword-retriever"> <i class="fa-solid fa-hashtag fa-sm"></i> keyword-retriever</a>   <a href="/blog/tag/rag"> <i class="fa-solid fa-hashtag fa-sm"></i> rag</a>   <a href="/blog/tag/whoosh"> <i class="fa-solid fa-hashtag fa-sm"></i> whoosh</a>   <a href="/blog/tag/python"> <i class="fa-solid fa-hashtag fa-sm"></i> python</a>   ·   <a href="/blog/category/rag"> <i class="fa-solid fa-tag fa-sm"></i> rag</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> <p>In this blog post I give you a tutorial on how to build a simple yet efficient keyword retriever for a RAG system, using the Whoosh library.</p> </blockquote> <h2 id="motivation">Motivation</h2> <p>I found myself building a RAG system for question answering, and it is not as easy as you might think.</p> <p>The main problem comes when dealing with technical documentation. Implementing a similarity search-based RAG will not help you much. Firstly, the embedding model does not know the keywords, so it cannot embed them properly. Secondly, when a user asks a question, the text is rarely “similar” to the chunk that contains the answer, if that makes sense.</p> <p>Although it does not solve all your problems, a first step towards improving your RAG in this setting is well known: you shall add a keyword retriever in addition to the similarity search-based retriever, as the both of them are complementary.</p> <p>This post will be useful for you in at least two ways: if you are curious about how a keyword retriever works in practice, and if, like me, you are using a database that does not have a keyword retriever included. Some might argue that I could have use the retriever from langchain but from what I understood it either loads all the documents in memory (not optimal) or needs elasticsearch as a backend, which my team and I did not want to do, as we weren’t using it for anything else in the project at hand.</p> <h2 id="whoosh">Whoosh</h2> <blockquote> <p>Before diving into the practical stuff, let me introduce Whoosh, which I will use to build the keyword retriever.</p> </blockquote> <p><a href="https://github.com/mchaput/whoosh" rel="external nofollow noopener" target="_blank">Whoosh</a> is a popular, fast, pure Python search engine library designed for adding search functionality to applications. It’s often used for indexing and searching textual data within Python applications, and it’s popular in cases where a lightweight, easy-to-integrate search solution is required.</p> <p>Key Features of Whoosh:</p> <ul> <li>Written in Pure Python: Whoosh is implemented entirely in Python, which makes it easy to install and run without external dependencies or a specific backend.</li> <li>Full-Text Search: It provides full-text search capabilities, including indexing and retrieving text-based data efficiently.</li> <li>Customizable: Whoosh is highly flexible and allows developers to customize search functionality with features like tokenizers, filters, and analyzers.</li> <li>Simple Integration: Whoosh is lightweight and can be embedded directly into Python applications without the need for external services, making it ideal for smaller-scale applications.</li> <li>Phrase and Boolean Search: Supports phrase searches, Boolean operators (AND, OR, NOT), and other advanced search features.</li> </ul> <p>Important note about Whoosh: It is now unmaintained, so you may want to use <a href="https://github.com/Sygil-Dev/whoosh-reloaded" rel="external nofollow noopener" target="_blank">“Whoosh Reloaded”</a> instead, a fork and continuation of the Whoosh project, which is actively maintained. The code I will give here works for Whoosh as well as for Whoosh Reloaded.</p> <h2 id="building-the-index">Building the index</h2> <p>The first thing we need to do is to build a reverse index. Whoosh gives a clear definition in its documentation:</p> <blockquote> <p>A reverse index is “Basically a table listing every word in the corpus, and for each word, the list of documents in which it appears. It can be more complicated (the index can also list how many times the word appears in each document, the positions at which it appears, etc.) but that’s how it basically works.” (Whoosh documentation)</p> </blockquote> <p>To build a second retriever for my RAG system, I reuse the chunks from the Chroma database I built for a previous blog post. That way, I will have two complementary retievers, retrieving on the same chunks. I build a little generator as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">database_iterator</span><span class="p">(</span><span class="n">database_dirpath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
    <span class="n">client</span> <span class="o">=</span> <span class="nf">get_db</span><span class="p">(</span><span class="n">database_dirpath</span><span class="p">)</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">client</span><span class="p">.</span><span class="n">_collection</span><span class="p">.</span><span class="nf">count</span><span class="p">():</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">offset=</span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">batch</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="nf">len</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="sh">"</span><span class="s">documents</span><span class="sh">"</span><span class="p">])</span>
        <span class="k">yield</span> <span class="n">batch</span>
</code></pre></div></div> <p>Find the full script <a href="https://github.com/GTimothee/RAG_experiments/blob/main/blogs/keyword_retriever/chromadb_iterator.py" rel="external nofollow noopener" target="_blank">here</a></p> <p>The next step consists in building a Schema.</p> <blockquote> <p>“Whoosh requires that you specify the fields of the index before you begin indexing. The Schema associates field names with metadata about the field, such as the format of the postings and whether the contents of the field are stored in the index.” (Whoosh documentation)</p> </blockquote> <p>The schema represents a document in the index. We will use <em>TEXT</em> and <em>STORED</em> fields, for each document. The <em>TEXT</em> field specifies the text to be indexed. The document and its terms will be added to the reverse index. The <em>STORED</em> fields are the fields that will be retrieved, if the document is retrieved.</p> <p>Here is my very simple schema:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">whoosh.fields</span> <span class="kn">import</span> <span class="n">Schema</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">,</span> <span class="n">STORED</span>
<span class="kn">from</span> <span class="n">whoosh.analysis</span> <span class="kn">import</span> <span class="n">StemmingAnalyzer</span>

<span class="n">stem_ana</span> <span class="o">=</span> <span class="nc">StemmingAnalyzer</span><span class="p">()</span>
<span class="n">schema</span> <span class="o">=</span> <span class="nc">Schema</span><span class="p">(</span>
    <span class="n">content</span><span class="o">=</span><span class="nc">TEXT</span><span class="p">(</span><span class="n">analyzer</span><span class="o">=</span><span class="n">stem_ana</span><span class="p">),</span>
    <span class="n">text_content</span><span class="o">=</span><span class="n">STORED</span><span class="p">,</span>
    <span class="n">metadata</span><span class="o">=</span><span class="n">STORED</span><span class="p">,</span>
<span class="p">)</span>
</code></pre></div></div> <p>As you can see, I index the content of the document, and I store the content and the metadata. I also added a custom analyzer. The goal of the StemmingAnalyzer is to store the stems of the words, instead of the words themselves, which allows to generalize better.</p> <p>More about analyzers: “An analyzer is a function […] that takes a unicode string and returns a generator of tokens”. (Whoosh documentation)</p> <p>More about the StemmingAnalyzer: It is a “pre-packaged analyzer that combines a tokenizer, lower-case filter, optional stop filter, and stem filter” (Whoosh documentation)</p> <p>We can now create an index from our schema…</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">whoosh.index</span> <span class="kn">import</span> <span class="n">create_in</span>

<span class="n">index_dirpath</span> <span class="o">=</span> <span class="c1"># where you want to store your index
</span><span class="n">ix</span> <span class="o">=</span> <span class="nf">create_in</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">index_dirpath</span><span class="p">),</span> <span class="n">schema</span><span class="p">)</span>
<span class="n">writer</span> <span class="o">=</span> <span class="n">ix</span><span class="p">.</span><span class="nf">writer</span><span class="p">()</span>
</code></pre></div></div> <p>…And load our chunks into the index:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="nf">database_iterator</span><span class="p">(</span><span class="sh">'</span><span class="s">data/chroma_db_1000</span><span class="sh">'</span><span class="p">):</span>
    <span class="n">batch_size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="sh">"</span><span class="s">documents</span><span class="sh">"</span><span class="p">])</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">batch_size</span> 

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span>
        <span class="n">writer</span><span class="p">.</span><span class="nf">add_document</span><span class="p">(</span>
            <span class="n">text_content</span><span class="o">=</span><span class="n">batch</span><span class="p">[</span><span class="sh">"</span><span class="s">documents</span><span class="sh">"</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
            <span class="n">content</span><span class="o">=</span><span class="n">batch</span><span class="p">[</span><span class="sh">"</span><span class="s">documents</span><span class="sh">"</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">batch</span><span class="p">[</span><span class="sh">"</span><span class="s">metadatas</span><span class="sh">"</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="p">)</span>

<span class="n">writer</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span>
</code></pre></div></div> <p>Find the full script <a href="https://github.com/GTimothee/RAG_experiments/blob/main/blogs/keyword_retriever/build_index.py" rel="external nofollow noopener" target="_blank">here</a></p> <h2 id="querying-the-index">Querying the index</h2> <p>Now that we have the index, let us write the retriever itself. Given a query, the retrieving process is pretty simple:</p> <ol> <li>preprocess the query: we want to apply the same preprocessing to the query that to the indexed documents, so that we can use the words stems for retrieval.</li> <li>translate the query into Whoosh query language (the same way we would translate our string into SQL for a SQL database)</li> <li>use that query against the index, leveraging a dedicated search algorithm</li> </ol> <p>To preprocess the query we remove stopwords using the <em>nltk</em> package, and we stem the words using the <code class="language-plaintext highlighter-rouge">whoosh.lang.porter.stem</code> function. Let us first download the stopwords (they will be downloaded only once).</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">nltk</span> 
<span class="kn">from</span> <span class="n">nltk.corpus</span> <span class="kn">import</span> <span class="n">stopwords</span>

<span class="n">stop_words</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">stopwords</span><span class="p">.</span><span class="nf">words</span><span class="p">(</span><span class="sh">"</span><span class="s">english</span><span class="sh">"</span><span class="p">))</span>
<span class="n">stop_words</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="sh">"</span><span class="s">?</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>For step 2, it is as simple as initializing a query parser. I use a simple QueryParser, but if you have several fields you want to look into at retrieval time, you can use the MultifieldParser instead. By default, the parser matches a document that contains all the terms specified in the query (using the AND operator). For example, “physically based rendering” will be parser “physically AND based AND rendering”. I change this behaviour by using the OR operator instead, and the “qparser.OrGroup.factory(0.9)” statement allows to give more weight to a document if it contains the words we are looking for multiple times.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">whoosh</span> <span class="kn">import</span> <span class="n">qparser</span>
<span class="kn">from</span> <span class="n">whoosh.qparser</span> <span class="kn">import</span> <span class="n">QueryParser</span>
<span class="kn">from</span> <span class="n">whoosh.index</span> <span class="kn">import</span> <span class="n">open_dir</span>

<span class="n">parser</span> <span class="o">=</span> <span class="nc">QueryParser</span><span class="p">(</span>
    <span class="sh">"</span><span class="s">content</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">ix</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span>
    <span class="n">group</span><span class="o">=</span><span class="n">qparser</span><span class="p">.</span><span class="n">OrGroup</span><span class="p">.</span><span class="nf">factory</span><span class="p">(</span><span class="mf">0.9</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">ix</span> <span class="o">=</span> <span class="nf">open_dir</span><span class="p">(</span><span class="n">index_dirpath</span><span class="p">)</span>
</code></pre></div></div> <p>Putting everything together, I get this preprocessing function:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">nltk.tokenize</span> <span class="kn">import</span> <span class="n">word_tokenize</span>
<span class="kn">from</span> <span class="n">whoosh.lang.porter</span> <span class="kn">import</span> <span class="n">stem</span>

<span class="k">def</span> <span class="nf">_process_query</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
    <span class="c1"># tokenize 
</span>    <span class="n">word_tokens</span> <span class="o">=</span> <span class="nf">word_tokenize</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">tokenized query: </span><span class="si">{</span><span class="n">word_tokens</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># stem and filter out stop words
</span>    <span class="n">filtered_query</span> <span class="o">=</span> <span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="nf">stem</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_tokens</span>
            <span class="k">if</span> <span class="n">word</span><span class="p">.</span><span class="nf">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stop_words</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">stemmed-filtered_query: </span><span class="si">{</span><span class="n">filtered_query</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="n">parsed_query</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">filtered_query</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">parsed_query: </span><span class="si">{</span><span class="n">parsed_query</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parsed_query</span>
</code></pre></div></div> <p>We can now use the ix.searcher method to search for the most relevant documents:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">whoosh</span> <span class="kn">import</span> <span class="n">scoring</span>
<span class="kn">from</span> <span class="n">langchain_core.documents</span> <span class="kn">import</span> <span class="n">Document</span>

<span class="n">k</span> <span class="o">=</span> <span class="c1"># integer representing the number of documents you want to retrieve
</span><span class="n">query</span> <span class="o">=</span> <span class="c1"># a string
</span>
<span class="k">with</span> <span class="n">ix</span><span class="p">.</span><span class="nf">searcher</span><span class="p">(</span><span class="n">weighting</span><span class="o">=</span><span class="n">scoring</span><span class="p">.</span><span class="nc">BM25F</span><span class="p">())</span> <span class="k">as</span> <span class="n">searcher</span><span class="p">:</span>
    <span class="n">formatted_query</span> <span class="o">=</span> <span class="nf">_process_query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">searcher</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="n">formatted_query</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="nc">Document</span><span class="p">(</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="sh">"</span><span class="s">metadata</span><span class="sh">"</span><span class="p">],</span> 
            <span class="n">page_content</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="sh">"</span><span class="s">text_content</span><span class="sh">"</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span>
    <span class="p">]</span>
</code></pre></div></div> <p>As you can see, we retrieve the STORED fields “text_content” and “metadata” from the schema.</p> <p>Find the full script <a href="https://github.com/GTimothee/RAG_experiments/blob/main/library/keyword_retriever.py" rel="external nofollow noopener" target="_blank">here</a></p> <h2 id="the-search-algorithm">The search algorithm</h2> <p>As you may notice, I am using the BM25F algorithm (the default in Whoosh) to perform the search. From what I saw, only the ‘frequency-based’, ‘TF-IDF’ and ‘BM25F’ algorithms are supported in Whoosh. Whoosh-reloaded supports two additional algorithms: PL2 and DFREE. The BM25 algorithm is considered better than TF-IDF and is pretty robust. PL2 and DFREE can be better depending on the dataset at hand, but do not guarantee better results.</p> <p>The BM25F algorithm is a variant of the BM25 algorithm that enables searching over multiple fields at the same time, which suits Whoosh well as we can define a schema with multiple fields to look into.</p> <h2 id="evaluation">Evaluation</h2> <p>On the first 200 samples of the huggingface documentation dataset, the traditional RAG with similarity search gave: 73% mean completeness and 52% mean conciseness. Here is the associated disrtibution of the target document rank in the results:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0.0    100
1.0     19
3.0     11
2.0     11
</code></pre></div></div> <p>It means that for half of the samples, we were able to find the target chunk with rank 0.</p> <p>I tried the same pipeline, replacing the similarity search-based retriever by the keyword retriever we built. I got 80% mean completeness and 56% mean conciseness. Here is the associated disrtibution of the target document rank in the results:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0.0    132
1.0     19
3.0      8
2.0      4
</code></pre></div></div> <p>We can see that the keyword retiever actually performs better than the similarity search based retriever ! Depending on the dataset, it may not always be the case, but the point is that a keyword retriever actually performs pretty good. In a future blog post, we will combine both retrievers and add a reranker on top to get the best of both worlds and hopefully get better results than using only one of the retrievers.</p> <p>If you want the details and the code of the evaluation framework I used, checkout the dedicated <a href="https://gtimothee.github.io/blog/2024/simple-test-procedure-for-rag/" rel="external nofollow noopener" target="_blank">blog post</a>.</p> <h2 id="conclusion">Conclusion</h2> <p>We saw how to build a robust yet simple keyword retriever using Whoosh.</p> <p><a href="https://medium.com/@timothee.guedon/motivation-b242b05c1e78" rel="external nofollow noopener" target="_blank">Medium link</a></p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/llamaindex-graphrag-implementation/">graphRAG implementation in Llama Index</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/patterns-to-problems-thoughts/">Stop Learning Patterns, Start Solving Problems - Lessons from Biology and Engineering</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/embedding-model-fine-tuning/">Embedding model fine-tuning</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/simple-test-procedure-for-rag/">Test procedure and metrics for RAG in 5 minutes</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Timothée Guédon. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?b7816bd189846d29eded8745f9c4cf77"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js" integrity="sha256-rjmgmaB99riUNcdlrDtcAiwtLIojSxNyUFdl+Qh+rB4=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let theme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===theme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"Projects",description:"My last projects",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"post-graphrag-implementation-in-llama-index",title:"graphRAG implementation in Llama Index",description:"The goal is to understand the implementation of graphRAG by llamaindex.",section:"Posts",handler:()=>{window.location.href="/blog/2025/llamaindex-graphrag-implementation/"}},{id:"post-stop-learning-patterns-start-solving-problems-lessons-from-biology-and-engineering",title:"Stop Learning Patterns, Start Solving Problems - Lessons from Biology and Engineering",description:"This blog explores the shift from rigid categorization to creative problem-solving, drawing parallels between biology&#39;s evolution and modern engineering practices.",section:"Posts",handler:()=>{window.location.href="/blog/2025/patterns-to-problems-thoughts/"}},{id:"post-embedding-model-fine-tuning",title:"Embedding model fine-tuning",description:"Embedding model fine-tuning",section:"Posts",handler:()=>{window.location.href="/blog/2024/embedding-model-fine-tuning/"}},{id:"post-how-to-write-your-own-keyword-retriever-in-5-minutes",title:"How to write your own keyword retriever in 5 minutes",description:"Tutorial on how to write your own keyword retriever using the whoosh library",section:"Posts",handler:()=>{window.location.href="/blog/2024/homemade-keyword-retriever/"}},{id:"post-test-procedure-and-metrics-for-rag-in-5-minutes",title:"Test procedure and metrics for RAG in 5 minutes",description:"Simple test procedure and metrics for your RAG in 5 minutes",section:"Posts",handler:()=>{window.location.href="/blog/2024/simple-test-procedure-for-rag/"}},{id:"news-rag-agent-with-neo4j-tuto-update",title:"RAG agent with Neo4j tuto update",description:"",section:"News",handler:()=>{window.location.href="/news/2025-02-11-RAG-agent-with-Neo4j-tuto-update/"}},{id:"news-new-repo-on-rag-experiments",title:"New repo on RAG experiments",description:"",section:"News",handler:()=>{window.location.href="/news/2024-10-27-RAG-experiments-repo/"}},{id:"news-hello-world",title:"Hello world",description:"",section:"News",handler:()=>{window.location.href="/news/2024-06-12-Hello-world!/"}},{id:"projects-smolagent-custom-tools",title:"Smolagent custom tools",description:"Tools I built and shared with the community while building an agent with the smolagents library.",section:"Projects",handler:()=>{window.location.href="/projects/1_smolagents_tools_project/"}},{id:"projects-knowledge-graphs-project",title:"Knowledge graphs project",description:"Experimenting with knowledge graphs and RAG applications",section:"Projects",handler:()=>{window.location.href="/projects/2_knowledge_graphs_project/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%74%69%6D%6F%74%68%65%65.%67%75%65%64%6F%6E@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=qc6CJjYAAAAJ","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js"></script> </body> </html>